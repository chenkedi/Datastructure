package linear.list;



class LinkedList<T>{
	//链表的节点单元
	@SuppressWarnings("hiding")
	class Node<T>{
		private T data;
		private Node<T> next=null;
		public Node(){
			super();
		}
		public Node(T data){
			this.data=data;
		}
	}
	//链表的头指针
	private Node<T> header;
	
	public LinkedList(){
		header=null;
	}
	
	
	/**
	 * 按序号查找链表中的元素
	 * 对于链表中的第i个元素，指向他的指针实际上是在前一个节点中的，本方法中的i的计数从1开始，意义为p指向的节点，而不是p所在的节点。
	 * 对于课程中的讨论，改成如题所示，程序时错误的。主要针对index非法输入中的index为负数的情况，应该返回null，实际上返回的是第一个节点
	 * @param index
	 * @return
	 */
	public T get(int index){
		Node<T> p=this.header;//设置用于移动的临时指针变量
		int i=1;//由于初始的p指向第一个节点，所以i从1开始，所以这里的i的意思是p指向的节点，而不是p所在的节点。
		
		while(p!=null && i<index){	
			p=p.next;
			i++;			
		}
		if(i==index)
			return p.data;
		else
			return null;
	}
	
	/**
	 * 按值查找链表中的元素
	 * @param data
	 * @return
	 */
	public T find(T element){
		Node<T> p=this.header;//设置用于移动的指针变量
		while(p!=null && !p.data.equals(element)){									
			p=p.next;
		}
		return p.data;
	}
	
	/**
	 * 求链表的表长
	 * 表长的计数从0开始，因为p等于某个节点的next域，但是p指向的是下一个节点。而长度是计算到当前节点，所以此处i的意义是技术到p所在的节点。
	 * @return
	 */
	public int length(){
		int i=0;
		Node<T> p=this.header;
		while(p!=null){
			p=p.next;
			i++;
		}
		return i;
	}
	
	/**
	 * 在链表中将节点插入到第index的位置，即在index-1的后面插入一个节点，这样被插入的节点就在第index位置了。所以(1<=i<=n+1)
	 * @param index，第几个节点，从1开始
	 * @param node 要插入的节点
	 */
	public void insert(int index,T nodeData){
		Node<T> p=this.header;
		
		//index=1，即插入的节点要在第一个，即在头指针后插入该节点
		if(index==1){
			Node<T> node=new Node<T>(nodeData);
			node.next=p;
			header=node;			
		}else if(index<1){
			System.out.println("您输入的索引值不合法！");
			return;
		}else{
			int i=1;//由于初始的p指向第一个节点，所以i从1开始，所以这里的i的意思是p指向的节点，而不是p所在的节点。
			//我们需要找到第index-1个节点的位置，然后将该节点插入到这个节点的后面，这样这个节点才是第index个节点
			for(;p!=null && i<index-1;i++){
				p=p.next;
			}
			if(i==index-1){
				Node<T> node=new Node<T>(nodeData);
				node.next=p.next;
				p.next=node;
			}else{
				System.out.println("您输入的索引值不合法！");
				return;
			}
		}	
	}
	
	/**
	 * 在链表中删除节点，节点计数从1开始
	 * @param index 第几个节点，从1开始
	 */
	public void delete(int index){
		Node<T> p=this.header;
		Node<T> del=null;//指向被删除的节点，方便释放
		if(index<1){
			System.out.println("您输入的索引值不合法！");
			return;
		}else if(index==1){//删除头结点的情况
			//用del记住需要删除的节点
			del=p;
			//如果该链表不为空，则可以删除
			if(this.header!=null){
				this.header=this.header.next;
				//将del和p都置为空，将对象解引用，并通知jvm回收该Node
				del=p=null;
				System.gc();
			}
			else{
				System.out.println("链表为空，无法删除！");
				return;
			}
			
		}else{
			int i=1;//由于初始的p指向第一个节点，所以i从1开始，所以这里的i的意思是p指向的节点，而不是p所在的节点。
			for(;p!=null && i<index-1;i++){
				p=p.next;
			}
			if(i==index-1){
				//p指向的是要删除节点的前一个节点，为了确保要删除的几点存在，p.next不能为空
				if(p.next!=null){
					//del记住要删除的节点
					del=p.next;
					p=p.next;
					del=null;
					System.gc();
				}				
			}else{
				System.out.println("第"+index+"个节点不存在");
				return;
			}
		}
	}
	
	/**
	 * 形象化打印当前的链表
	 * @return 
	 */
	public void print(){
		Node<T> p=this.header;
		System.out.print("\n header——>");
		while(p!=null){
			System.out.print(" |"+p.data+":pointer| ——>");
			p=p.next;
		}
		System.out.println("null");		
	}
		
}


public class LinkedLists
{
	public static void main(String[] args){
		LinkedList<Integer> list=new LinkedList<Integer>();
		list.insert(1, 1);
		list.insert(2, 2);
		list.insert(3, 3);
		list.insert(4, 4);
		list.insert(5, 5);
		
		list.insert(1, 100);
		
		list.delete(6);
		list.delete(1);
		System.out.println("链表长度："+list.length());
		list.print();
	}
}
